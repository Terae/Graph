/*
 *    ╔═╗╦═╗╔═╗╔═╗╦ ╦  C++ Graph library
 *    ║ ╦╠╦╝╠═╣╠═╝╠═╣  Version 1.0.0
 *    ╚═╝╩╚═╩ ╩╩  ╩ ╩  https://github.com/Terae/Structure
 *
 *
 * Single header-file generated by terae on 2018-01-06
 *
 *
 * Licensed under the MIT License <https://opensource.org/licenses/MIT>.
 * Copyright (c) 2017 Benjamin BIGEY
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to wholm the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 *
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef ROOT_GRAPH_FINAL_H
#define ROOT_GRAPH_FINAL_H

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <map>
#include <vector>

#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_MSC_VER) && _MSC_VER > 1900 && defined(_HAS_CXX17) && _HAS_CXX17 == 1)
    #define GRAPH_HAS_CPP_17
    #define GRAPH_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define GRAPH_HAS_CPP_14
#endif

#if defined(GRAPH_HAS_CPP_17)
    #include <optional>
#endif

#if defined(__clang__)
    #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30500
        #error "unsupported Clang version - see https://github.com/terae/structure#supported-compilers"
    #endif
#elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
    #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 50000
        #error "unsupported GCC version - see https://github.com/terae/structure#supported-compilers"
    #endif
#endif

#include <functional>
#include <iostream>
#include <list>
#include <memory>
#include <tuple>
#include <utility>

//! allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && not defined(GRAPH_NOEXCEPTION)
    #define GRAPH_THROW(exception_name) throw detail::exception_name::create(__FUNCTION__);
    #if defined(__clang__)
        #define GRAPH_THROW_WITH(exception_name, ...) throw detail::exception_name::create(__FUNCTION__, __VA_ARGS__);
    #elif defined(__GNUC__)
        #define GRAPH_THROW_WITH(exception_name, ...) throw detail::exception_name::create(__FUNCTION__, ##__VA_ARGS__);
    #endif
    #define GRAPH_TRY try
    #define GRAPH_CATCH(exception) catch(exception)
#else
    #define GRAPH_THROW(exception) std::abort()
    #define GRAPH_TRY if (true)
    #define GRAPH_CATCH(exception) if (false)
#endif

#include <functional>
#include <limits>

enum Nature {
    DIRECTED   = 'd',
    UNDIRECTED = 'u'
};

/*!
 @brief unnamed namespace with internal helper functions

 This namespace collects some functions that could not be defined inside the @ref graph class.
 */
namespace detail {
//!
//! @section exceptions
//!

    /*!
     @brief general exception of the @ref graph class

     This class is an extension of `std::exception` objects.
     It is used as the base class for all exceptions thrown
     by the @ref graph class for logical errors.
     This class can hence be used as "wildcard" to catch exceptions.

     Subclasses:
     - @ref invalid_argument for exceptions indicating invalid arguments given to some function
     - @ref unexpected_nullptr for exceptions indicating an unexpected nullptr in entry
     - @ref parse_error for exceptions indicating a parse error
     - @ref bad_graph for exceptions indicating a logical error in the usage of the @ref graph class
     */
    struct exception : public std::exception {
        const char *what() const noexcept override {
            return m.what();
        }

    protected:
        explicit exception(const char *what_arg) : m(what_arg) {}

        static std::string name(const std::string &exception_type) {
            return "[graph.exception." + exception_type + "] ";
        }

    private:
        std::logic_error m;
    };

    struct invalid_argument final : public exception {
        static invalid_argument
        create(const std::string &function_name, const std::string &what_arg = "Invalid argument") {
            std::string w{exception::name("invalid_argument") + what_arg + " when calling '" + function_name + "'."};
            return invalid_argument(w.c_str());
        }

    private:
        explicit invalid_argument(const char *what_arg) : exception(what_arg) {}
    };

    struct unexpected_nullptr final : public exception {
        static unexpected_nullptr create(const std::string &function_name,
                                         const std::string &what_arg = "Unexpected nullptr") {
            std::string w{exception::name("unexpected_nullptr") + what_arg + " when calling '" + function_name + "'."};
            return unexpected_nullptr(w.c_str());
        }

    private:
        explicit unexpected_nullptr(const char *what_arg) : exception(what_arg) {}
    };

    struct parse_error final : public exception {
        static parse_error create(const std::string &function_name,
                                  std::size_t byte,
                                  const std::string &what_arg = "Bad format") {
            std::string w{exception::name("parse_error") + "parse error"
                          + (byte != 0 ? " at " + std::to_string(byte) : "")
                          + ": " + what_arg + " when calling '" + function_name + "'."};
            return parse_error(w.c_str(), byte);
        }

        const std::size_t byte;

    private:
        explicit parse_error(const char *what_arg, std::size_t b) : exception(what_arg), byte(b) {}
    };

    /*!
     @brief specialized logical exception of the @ref graph class

     Subclasses:
     - @ref negative_edge for exceptions indicating a negative edge error, throwable in some search algorithms
     - @ref not_complete for exceptions indicating a non-complete graph error
     */
    struct bad_graph : public exception {
    protected:
        explicit bad_graph(const char *what_arg) : exception(what_arg) {}

        static std::string name(const std::string &exception_type) {
            return "[graph.exception.bad_graph." + exception_type + "] ";
        }
    };

    struct negative_edge final : public bad_graph {
        static negative_edge create(const std::string &function_name,
                                    const std::string &what_arg = "Edge with negative weight") {
            std::string w{bad_graph::name("negative_edge") + what_arg + " when calling '" + function_name + "'."};
            return negative_edge(w.c_str());
        }

    private:
        explicit negative_edge(const char *what_arg) : bad_graph(what_arg) {}
    };

    struct not_complete final : public bad_graph {
        static not_complete create(const std::string &function_name,
                                   const std::string &what_arg = "Not complete graph") {
            std::string w{bad_graph::name("not_complete") + what_arg + " when calling '" + function_name + "'."};
            return not_complete(w.c_str());
        }

    private:
        explicit not_complete(const char *what_arg) : bad_graph(what_arg) {}
    };

//!
//! @section degree
//!
    template <Nature N> class basic_degree;

    template <> class basic_degree<DIRECTED> {
    public:
        using value_type = std::pair<std::size_t, std::size_t>;

        basic_degree(const value_type& degree) : _deg(degree) {};
        basic_degree(std::size_t in, std::size_t out) : basic_degree(std::make_pair(in, out)) {};

        inline value_type get_degree() const { return _deg; }

        bool operator==(const basic_degree& d) const { return _deg == d._deg; }
        bool operator==(const value_type& v)   const { return _deg == v; }

        bool operator< (const basic_degree& d) const { return _deg < d._deg; }

        static basic_degree max() { return basic_degree(std::numeric_limits<std::size_t>::max(), std::numeric_limits<std::size_t>::max()); }
        static basic_degree min() { return basic_degree(std::numeric_limits<std::size_t>::min(), std::numeric_limits<std::size_t>::min()); }

    private:
        value_type _deg;
    };

    template <> class basic_degree<UNDIRECTED> {
    public:
        using value_type = std::size_t;

        basic_degree(const value_type& d) : _deg(d) {}
        basic_degree(std::size_t in, std::size_t) : basic_degree(in) {}

        inline value_type get_degree() const { return _deg; }

        bool operator==(const basic_degree& d) const { return _deg == d._deg; }
        bool operator==(const value_type& v)   const { return _deg == v; }

        bool operator< (const basic_degree& d) const { return _deg < d._deg; }

        static basic_degree max() { return basic_degree(std::numeric_limits<std::size_t>::max()); }
        static basic_degree min() { return basic_degree(std::numeric_limits<std::size_t>::min()); }

    private:
        value_type _deg;
    };

//!
//! @section helpers
//!
#include <memory>
    //! distinguish value type between map::iterator and shared_ptr: @see https://stackoverflow.com/a/31409532
    template <typename... >
    using void_t = void;

    template <typename T, typename = void>
    struct is_map_iterator : std::false_type { };

    template <typename T>
    struct is_map_iterator<T,
            void_t<decltype(++std::declval<T&>()),
                   decltype(*std::declval<T&>()),
                   decltype(std::declval<T&>() == std::declval<T&>()),
                   decltype((*std::declval<T&>()).second)> >
            : std::true_type { };

    template <class V, class = typename std::enable_if<is_map_iterator<V>::value>::type>
    inline typename std::iterator_traits<V>::value_type::second_type get_value(const V &v, const V &end) {
        if (v == end)
            return static_cast<typename std::iterator_traits<V>::value_type::second_type>(nullptr);
        return (*v).second;
    }

#include <cxxabi.h>

    //! @return the name of the @tparam T

    template <class T>
    std::string type_name() {
        int status;
        std::string tname{typeid(T).name()};
        char *demangled_name{abi::__cxa_demangle(tname.c_str(), NULL, NULL, &status)};

        if (status == 0)
            tname = demangled_name;
        std::free(demangled_name);

        std::function<void(std::string&, std::string, std::string)> replace_all =
                [](std::string& base, std::string to_replace, std::string replacement) {
                    for (std::string::size_type i{0}; (i = base.find(to_replace, i)) != std::string::npos; ) {
                        base.replace(i, to_replace.length(), replacement);
                        i += replacement.length();
                    }
                };

        replace_all(tname, "std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >", "std::string>");
        replace_all(tname, "std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >",   "std::string");
        return tname;
    }

    template <class T>
    std::istream& read_T(std::istream& is, T& t) {
        is.ignore(std::numeric_limits<std::streamsize>::max(), '"');

        std::string str;
        std::getline(is, str, '"');
        std::stringstream ss;
        ss << str;
        if (!(ss >> t))
            GRAPH_THROW_WITH(parse_error, 5, "Bad type");

        return is;
    }
    template<> inline
    std::istream& read_T<std::string>(std::istream& is, std::string& str) {
        is.ignore(std::numeric_limits<std::streamsize>::max(), '"');
        std::getline(is, str, '"');
        return is;
    }

    template <class C>
    std::istream& read_cost(std::istream& is, C& c) {
        std::string str = std::string(std::istreambuf_iterator<char>(is),
                                      std::istreambuf_iterator<char>());
        if (str.find_first_of("\"") == std::string::npos &&
            str.find_first_of("infinity") != std::string::npos)
            c = std::numeric_limits<C>::has_infinity ? std::numeric_limits<C>::infinity() :
                std::numeric_limits<C>::max();
        else {
            std::stringstream ss;
            ss << str;
            read_T(ss, c);
        }
        return is;
    }
}

template <class Data, class Cost, class Container, class constContainer>
class basic_node {
private:
    template <class K, class T, class C, Nature N>
    friend class graph;

    struct edge;
    typedef std::list<edge> ListEdges;
    typedef typename ListEdges::iterator EdgesIterator;

    ListEdges _out_edges;

    const Cost infinity = std::numeric_limits<Cost>::has_infinity ? std::numeric_limits<Cost>::infinity() :
                          std::numeric_limits<Cost>::max();

    std::size_t _in_degree{0};

    struct edge {
        std::weak_ptr<basic_node<Data, Cost, Container, constContainer> > target;
        std::shared_ptr<Cost> cost;

        edge(const std::weak_ptr<basic_node<Data, Cost, Container, constContainer> > &ptr, Cost c);

        std::tuple<Cost, basic_node<Data, Cost, Container, constContainer> > tie() const;

        bool operator< (const edge &other) const;

        bool operator==(const edge &other) const;

        constContainer get_container() const;
    };

    inline void increment_in_degree(int n = 1);
    inline void decrement_in_degree(int n = 1);

    //! used for UNDIRECTED graphs: same Cost in memory for both directions
    bool set_edge(constContainer other, std::shared_ptr<Cost> cost);

    std::tuple<Data, std::size_t, ListEdges> tie() const;

    inline ListEdges get_edges() const;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator==(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator!=(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator<(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator<=(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator>(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    template <class T, class C, class X, class Y>
    friend constexpr bool operator>=(const basic_node<T, C, X, Y>& n1, const basic_node<T, C, X, Y>& n2) noexcept;

    basic_node(const basic_node &n);

    basic_node &operator=(const basic_node &n);

protected:
    Data _data;

    Container      container_from_this;
    Container      end_container;
    constContainer cend_container;

public:
    //!
    //! @section exceptions
    //!
    using exception          = detail::exception;
    using invalid_argument   = detail::invalid_argument;
    using unexpected_nullptr = detail::unexpected_nullptr;

    //!
    //! @section Constructors
    //!
    explicit basic_node();

    explicit basic_node(const Data &d);

    basic_node &operator=(basic_node&& n) = delete;

    ~basic_node();

    //!
    //! @section Element access
    //!

    inline Data &get();

    inline Data get() const;

          Cost &get_cost(const Container &other);
    const Cost  get_cost(constContainer   other) const;

          Cost &operator[](Container      other);
    const Cost  operator[](constContainer other) const;

    //!
    //! @section Modifiers
    //!
    template<class T_data>
    inline void set(const T_data &d);

    template<class T_cost>
    void set_cost(Container other, const T_cost &c);

    //! Adders

    std::pair<EdgesIterator, bool> add_edge(constContainer other, Cost cost = Cost(1)) {
        std::shared_ptr<basic_node<Data, Cost, Container, constContainer> > ptr{detail::get_value(other, cend_container)};

        if (ptr == nullptr)
            GRAPH_THROW(unexpected_nullptr)

        for (EdgesIterator it{_out_edges.begin()}; it != _out_edges.end(); ++it)
            if (it->target.lock() == ptr) {
                *it->cost = cost;
                return std::make_pair(it, false);
            }

        //! Link doesn't exist
        ptr->increment_in_degree();
        _out_edges.emplace_back(std::weak_ptr<basic_node<Data, Cost, Container, constContainer> >(ptr), cost);
        std::pair<EdgesIterator, bool> result{std::make_pair(--_out_edges.end(), true)};
        return result;
    }

    //! Deleters
    bool del_edge   (constContainer other);
    bool del_edge_if(constContainer other, std::function<bool(edge)> predicate);

    std::size_t clear_edges();

    //!
    //! @section Operations
    //!

    inline std::pair<std::size_t, std::size_t> degree() const;

    bool existing_adjacent_node(constContainer other) const;
};

/*!
 * @brief a generalized class of Graph
 *
 * @tparam Key type of the keys. Each element in a Graph is uniquely identified by its key value. Aliased as member type Graph::key_type
 * @tparam T type of graphed value stored into a node. Aliased as member type Graph::graphed_type
 * @tparam Cost type of the cost between nodes.
 */
template <class Key, class T, class Cost = std::size_t, Nature Nat = UNDIRECTED>
class graph {
public:
    class node;
    using Degree = detail::basic_degree<Nat>;

private:
    using PtrNode  = std::shared_ptr<node>;
    using MapNodes = std::map<Key, PtrNode>;

    MapNodes _nodes;
    std::size_t _num_edges = 0;

    const Cost infinity = std::numeric_limits<Cost>::has_infinity ? std::numeric_limits<Cost>::infinity() :
                                                                    std::numeric_limits<Cost>::max();

    std::ostream &print(std::ostream &os) const;

public:

    //!
    //! @section exceptions
    //!

    using bad_graph          = detail::bad_graph;
    using exception          = detail::exception;
    using invalid_argument   = detail::invalid_argument;
    using negative_edge      = detail::negative_edge;
    using not_complete       = detail::not_complete;
    using parse_error        = detail::parse_error;
    using unexpected_nullptr = detail::unexpected_nullptr;

    //!
    //! @section container types
    //!

    using value_type   = std::pair<const Key, PtrNode>;

    using reference    = value_type &;

    using key_type     = Key;

    using graphed_type = T;

    using size_type    = std::size_t;

    using iterator               = typename std::map<Key, PtrNode>::iterator;

    using const_iterator         = typename MapNodes::const_iterator;

    using reverse_iterator       = typename MapNodes::reverse_iterator;

    using const_reverse_iterator = typename MapNodes::const_reverse_iterator;

    //!
    //! @section Iterators
    //!

    iterator begin() noexcept;
    iterator end()   noexcept;

    const_iterator begin()  const noexcept;
    const_iterator cbegin() const noexcept;

    const_iterator end()  const noexcept;
    const_iterator cend() const noexcept;

    reverse_iterator rbegin() noexcept;
    reverse_iterator rend()   noexcept;

    const_reverse_iterator rbegin()  const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    const_reverse_iterator rend()  const noexcept;
    const_reverse_iterator crend() const noexcept;

    //!
    //! @section Constructors
    //!

    explicit graph();

    graph(const graph &);

    graph(graph &&) noexcept;

    graph &operator=(const graph &);

    graph &operator=(graph &&);

    virtual ~graph();

    //!
    //! @section Capacity
    //!

    bool empty() const noexcept;

    size_type size() const noexcept;

    size_type max_size() const noexcept;

    //!
    //! @section Element access
    //!

    graphed_type &operator[](const key_type &);
    graphed_type &operator[](key_type &&);

#if defined(GRAPH_HAS_CPP_17)
    const std::optional<graphed_type> operator[](key_type &&) const;
#else
    const graphed_type operator[](key_type &&) const;
#endif

    Cost &operator()(iterator,         iterator);
    Cost &operator()(const key_type &, const key_type &);

#if defined(GRAPH_HAS_CPP_17)
    const std::optional<Cost> operator()(const_iterator,   const_iterator)   const;
    const std::optional<Cost> operator()(const key_type &, const key_type &) const;
#else
    const Cost operator()(const_iterator it1, const_iterator it2)  const;
    const Cost operator()(const key_type &k1, const key_type &k2)  const;
#endif
    //!
    //! @section Modifiers
    //!

    //! Adders

    [[deprecated]] std::pair<iterator, bool> insert(const value_type &);

    iterator insert(const_iterator position, const value_type &);
    iterator insert(const_iterator position, const key_type &, graphed_type &);
    iterator insert(const_iterator position, const key_type &, const node &);

    std::pair<iterator, bool> emplace(const key_type &);
    std::pair<iterator, bool> emplace(const key_type &, const graphed_type &);
    std::pair<iterator, bool> emplace(const key_type &, const node &);

    std::pair<iterator, bool> add_node(const key_type &);
    std::pair<iterator, bool> add_node(const key_type &, const graphed_type &);
    std::pair<iterator, bool> add_node(const key_type &, const node &);

    bool add_edge(const_iterator,   const_iterator,   Cost = std::numeric_limits<Cost>::epsilon());
    bool add_edge(const key_type &, const key_type &, Cost = std::numeric_limits<Cost>::epsilon());

    void link_all_nodes(Cost cost);

    //! Deleters

    iterator  erase(const_iterator);
    iterator  erase(const_iterator first, const_iterator last);
    size_type erase(const key_type &);

    iterator  del_node (const_iterator);
    iterator  del_nodes(const_iterator first, const_iterator last);
    size_type del_node (const key_type &);

    void clear() noexcept;

    size_type del_edge(const_iterator,   const_iterator);
    size_type del_edge(const key_type &, const key_type &);

    void clear_edges();

    size_type clear_edges(const_iterator);
    size_type clear_edges(const key_type &);

    //! Others
    void swap(graph &);

    //!
    //! @section Functions
    //!

    size_type count(const key_type &) const;

    iterator       find(const key_type &);
    const_iterator find(const key_type &) const;

    //!
    //! @section Operations
    //!

    bool existing_node(const_iterator)   const;
    bool existing_node(const key_type &) const;

    bool existing_edge(const_iterator,   const_iterator)   const;
    bool existing_edge(const key_type &, const key_type &) const;

    inline size_type get_nbr_nodes() const noexcept;
    inline size_type get_nbr_edges() const noexcept;

    inline Nature get_nature() const;

    Degree degree(const_iterator)   const;
    Degree degree(const key_type &) const;

    std::pair<const_iterator, Degree> degree_max() const;
    std::pair<const_iterator, Degree> degree_min() const;

    std::map<key_type, Degree> degrees() const;

    //!
    //! @section Text functions
    //!

    template<class K, class D, class C, Nature N> friend std::ostream &operator<<(std::ostream &os, const graph<K, D, C, N> &g);
    template<class K, class D, class C, Nature N> friend std::istream &operator>>(std::istream &is,       graph<K, D, C, N> &g);

    void save  (const char *filepath) const;
    graph &load(const char *filepath);

    //!
    //! @section Bool operators
    //!

    template<class K, class D, class C, Nature N> bool operator==(const graph<K, D, C, N> &other) const noexcept;
    template<class K, class D, class C, Nature N> bool operator!=(const graph<K, D, C, N> &other) const noexcept;

    class node : public basic_node<T, Cost, iterator, const_iterator> {
    public:
        explicit node();

        explicit node(const T &);

        node &operator=(const T &);

    private:
        friend class graph;

        void set_iterator_values(iterator this_, iterator end, const_iterator cend);
    };
};

template <class Key, class T, class Cost = std::size_t>
using graph_directed = graph<Key, T, Cost, DIRECTED>;

template <class Key, class T, class Cost = std::size_t>
using graph_undirected = graph<Key, T, Cost, UNDIRECTED>;

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>::edge::edge(const std::weak_ptr<basic_node<Data, Cost, Container, constContainer> > &ptr, Cost c) : target(ptr),
                                                                                   cost(std::make_shared<Cost>(c)) {}

template <class Data, class Cost, class Container, class constContainer>
std::tuple<Cost, basic_node<Data, Cost, Container, constContainer> > basic_node<Data, Cost, Container, constContainer>::edge::tie() const {
    return std::tie(*cost, *target.lock().get());
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::edge::operator<(const edge &other) const {
    return tie() < other.tie();
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::edge::operator==(const edge &other) const {
    return tie() == other.tie();
}

template <class Data, class Cost, class Container, class constContainer>
constContainer basic_node<Data, Cost, Container, constContainer>::edge::get_container() const {
    return target.lock()->container_from_this;
}

template <class Data, class Cost, class Container, class constContainer>
std::tuple<Data, std::size_t, std::list<typename basic_node<Data, Cost, Container, constContainer>::edge> > basic_node<Data, Cost, Container, constContainer>::tie() const {
    return std::tie(_data, _in_degree, _out_edges);
}

template <class Data, class Cost, class Container, class constContainer>
std::list<typename basic_node<Data, Cost, Container, constContainer>::edge> basic_node<Data, Cost, Container, constContainer>::get_edges() const {
    return _out_edges;
}

template <class Data, class Cost, class Container, class constContainer>
void basic_node<Data, Cost, Container, constContainer>::increment_in_degree(int n) {
    _in_degree += n;
}

template <class Data, class Cost, class Container, class constContainer>
void basic_node<Data, Cost, Container, constContainer>::decrement_in_degree(int n) {
    _in_degree -= n;
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::set_edge(constContainer other, std::shared_ptr<Cost> cost) {
    std::pair<basic_node<Data, Cost, Container, constContainer>::EdgesIterator, bool> new_edge{add_edge(other, *cost)};

    new_edge.first->cost = cost;

    return new_edge.second;
}

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>::basic_node() : basic_node(Data()) {}

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>::basic_node(const Data& d) : _data(d) {}

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>::basic_node(const basic_node& n) {
    *this = n;
}

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>& basic_node<Data, Cost, Container, constContainer>::operator=(const basic_node& n) {
    _data               = n._data;
    _out_edges          = n._out_edges;
    _in_degree          = n._in_degree;
    container_from_this = n.container_from_this;

    return *this;
}

template <class Data, class Cost, class Container, class constContainer>
basic_node<Data, Cost, Container, constContainer>::~basic_node() {
    clear_edges();
}

template <class Data, class Cost, class Container, class constContainer>
inline Data& basic_node<Data, Cost, Container, constContainer>::get() {
    return _data;
}

template <class Data, class Cost, class Container, class constContainer>
inline Data basic_node<Data, Cost, Container, constContainer>::get() const {
    return _data;
}

template <class Data, class Cost, class Container, class constContainer>
Cost& basic_node<Data, Cost, Container, constContainer>::get_cost(const Container &other) {
    std::shared_ptr<basic_node<Data, Cost, Container, constContainer> > ptr(detail::get_value(other, end_container));

    if (ptr == nullptr)
        GRAPH_THROW(unexpected_nullptr)

    for (EdgesIterator it{_out_edges.begin()}; it != _out_edges.end(); ++it)
        if (it->target.lock() == ptr)
            return *(it->cost);

    //! Link doesn't exist
    _out_edges.emplace_back(std::weak_ptr<basic_node<Data, Cost, Container, constContainer> >(detail::get_value(other, end_container)), infinity);
    ptr->increment_in_degree();
    return *((--_out_edges.end())->cost);
}

template <class Data, class Cost, class Container, class constContainer>
const Cost basic_node<Data, Cost, Container, constContainer>::get_cost(constContainer other) const {
    std::shared_ptr<basic_node<Data, Cost, Container, constContainer> > ptr(detail::get_value(other, cend_container));

    if (ptr == nullptr)
        GRAPH_THROW(unexpected_nullptr)

    for (auto/*EdgesIterator*/ it = _out_edges.begin(); it != _out_edges.end(); ++it)
        if (it->target.lock() == ptr)
            return *(it->cost);

    //! Link doesn't exist
    return infinity;
}

template <class Data, class Cost, class Container, class constContainer>
Cost& basic_node<Data, Cost, Container, constContainer>::operator[](Container other) {
    return get_cost(other);
}

template <class Data, class Cost, class Container, class constContainer>
const Cost basic_node<Data, Cost, Container, constContainer>::operator[](constContainer other) const {
    return get_cost(other);
}

template <class Data, class Cost, class Container, class constContainer>
template <class T_data>
inline void basic_node<Data, Cost, Container, constContainer>::set(const T_data& d) {
    _data = static_cast<Data>(d);
}

template <class Data, class Cost, class Container, class constContainer>
template <class T_cost>
void basic_node<Data, Cost, Container, constContainer>::set_cost(Container other, const T_cost& c) {
    std::shared_ptr<basic_node<Data, Cost, Container, constContainer> > ptr(detail::get_value(other, end_container));

    if (ptr == nullptr)
        GRAPH_THROW(unexpected_nullptr)

    Cost new_cost{static_cast<Cost>(c)};

    bool existing_edge{false};

    for (EdgesIterator it{_out_edges.begin()}; it != _out_edges.end(); ++it)
        if (it->target.lock() == ptr) {
            *(it->cost) = new_cost;
            existing_edge = true;
        }

    if (!existing_edge)
        this->add_edge(other, new_cost);
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::del_edge(constContainer other) {
    return del_edge_if(other, [](edge){ return true;} );
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::del_edge_if(constContainer other, std::function<bool(edge)> predicate) {
    for (EdgesIterator it{_out_edges.begin()}; it != _out_edges.end();)
        if (it->target.lock() == detail::get_value(other, cend_container)) {
            if (predicate(*it)) {
                it = _out_edges.erase(it);
                other->second->decrement_in_degree();
                return true;
            }
            break;
        } else
            ++it;

    return false;
}

template <class Data, class Cost, class Container, class constContainer>
std::size_t basic_node<Data, Cost, Container, constContainer>::clear_edges() {
    const std::size_t NUM{_out_edges.size()};

    for (EdgesIterator it{_out_edges.begin()}; it != _out_edges.end(); ) {
        it->target.lock()->decrement_in_degree();
        it = _out_edges.erase(it);
    }

    return NUM;
}

template <class Data, class Cost, class Container, class constContainer>
inline std::pair<std::size_t, std::size_t> basic_node<Data, Cost, Container, constContainer>::degree() const {
    return std::make_pair(_in_degree, _out_edges.size());
}

template <class Data, class Cost, class Container, class constContainer>
bool basic_node<Data, Cost, Container, constContainer>::existing_adjacent_node(constContainer other) const {
    std::shared_ptr<basic_node<Data, Cost, Container, constContainer> > ptr(detail::get_value(other, cend_container));

    if (ptr == nullptr)
        return false;

    for (auto/*EdgesIterator*/ it = _out_edges.begin(); it != _out_edges.end(); ++it)
        if (it->target.lock() == ptr)
            return true;

    //! Link doesn't exist
    return false;
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator==(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return n1.tie() == n2.tie();
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator!=(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return !(n1 == n2);
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator<(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return n1.tie() < n2.tie();
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator>(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return n2 < n1;
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator<=(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return !(n2 < n1);
}

template <class Data, class Cost, class Container, class constContainer>
constexpr bool operator>=(const basic_node<Data, Cost, Container, constContainer>& n1, const basic_node<Data, Cost, Container, constContainer>& n2) noexcept {
    return !(n1 < n2);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::begin() noexcept {
    return _nodes.begin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::end() noexcept {
    return _nodes.end();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_iterator graph<Key, T, Cost, Nat>::begin() const noexcept {
    return _nodes.begin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_iterator graph<Key, T, Cost, Nat>::cbegin() const noexcept {
    return _nodes.cbegin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_iterator graph<Key, T, Cost, Nat>::end() const noexcept {
    return _nodes.end();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_iterator graph<Key, T, Cost, Nat>::cend() const noexcept {
    return _nodes.cend();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::reverse_iterator graph<Key, T, Cost, Nat>::rbegin() noexcept {
    return _nodes.rbegin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::reverse_iterator graph<Key, T, Cost, Nat>::rend() noexcept {
    return _nodes.rend();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_reverse_iterator graph<Key, T, Cost, Nat>::rbegin() const noexcept {
    return _nodes.rbegin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_reverse_iterator graph<Key, T, Cost, Nat>::crbegin() const noexcept {
    return _nodes.crbegin();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_reverse_iterator graph<Key, T, Cost, Nat>::rend() const noexcept {
    return _nodes.rend();
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_reverse_iterator graph<Key, T, Cost, Nat>::crend() const noexcept {
    return _nodes.crend();
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::graph() {
    _nodes.clear();
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::graph(const graph &g) {
    *this = g;
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::graph(graph &&g) noexcept {
    swap(g);
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>& graph<Key, T, Cost, Nat>::operator=(const graph &g) {
    clear();

    for (const_iterator it{g.cbegin()}; it != g.cend(); ++it)
        add_node(it->first, it->second->get());

    for (const_iterator it{g.cbegin()}; it != g.cend(); ++it) {
        auto list = it->second->get_edges();
        for (auto edge : list) {
            graph::const_iterator i{edge.get_container()};
            add_edge(it->first, i->first, *edge.cost);
        }
    }

    return *this;
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>& graph<Key, T, Cost, Nat>::operator=(graph &&g) {
    //! If there is a self-reference: bug in the client part that should be fixed
    if (this == &g)
        GRAPH_THROW_WITH(invalid_argument, "Self-reference in the client part")

    swap(g);
    return *this;
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::~graph() {
    clear();
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::empty() const noexcept {
    return _nodes.empty();
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::size() const noexcept {
    return _nodes.size();
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::max_size() const noexcept {
    return _nodes.max_size();
}

template <class Key, class T, class Cost, Nature Nat>
T& graph<Key, T, Cost, Nat>::operator[](const key_type& k) {
    return add_node(k).first->second->get();
}

template <class Key, class T, class Cost, Nature Nat>
T& graph<Key, T, Cost, Nat>::operator[](key_type&& k) {
    return add_node(k).first->second->get();
}

#if defined(GRAPH_HAS_CPP_17)
template <class Key, class T, class Cost, Nature Nat>
const std::optional<T> graph<Key, T, Cost, Nat>::operator[](key_type&& k) const {
    const_iterator it{find(k)};
    return it == cend() ? std::nullopt : std::optional<T>(it->second->get());
}
#else
template <class Key, class T, class Cost, Nature Nat>
const T graph<Key, T, Cost, Nat>::operator[](key_type&& k) const {
    const_iterator it{find(k)};
    if (it == cend())
        GRAPH_THROW_WITH(invalid_argument, "Unexistant node")

    return it->second->get();
}
#endif

template <class Key, class T, class Cost, Nature Nat>
Cost& graph<Key, T, Cost, Nat>::operator()(iterator it1, iterator it2) {
    if (!existing_edge(it1, it2))
        add_edge(it1, it2, infinity);

    return it1->second->get_cost(it2);
}

template <class Key, class T, class Cost, Nature Nat>
Cost& graph<Key, T, Cost, Nat>::operator()(const key_type& k1, const key_type& k2) {
    iterator it1{add_node(k1).first};
    iterator it2{add_node(k2).first};

    return operator()(it1, it2);
}

#if defined(GRAPH_HAS_CPP_17)
template <class Key, class T, class Cost, Nature Nat>
const std::optional<Cost> graph<Key, T, Cost, Nat>::operator()(const_iterator it1, const_iterator it2) const {
    return existing_edge(it1, it2) ? std::optional<Cost>(it1->second->get_cost(it2)) : std::nullopt;
}

template <class Key, class T, class Cost, Nature Nat>
const std::optional<Cost> graph<Key, T, Cost, Nat>::operator()(const key_type& k1, const key_type& k2) const {
    return operator()(find(k1), find(k2));
}
#else
template <class Key, class T, class Cost, Nature Nat>
const Cost graph<Key, T, Cost, Nat>::operator()(const_iterator it1, const_iterator it2) const {
    if (!existing_edge(it1, it2))
        GRAPH_THROW_WITH(invalid_argument, "Unexistant edge")

    return it1->second->get_cost(it2);
}

template <class Key, class T, class Cost, Nature Nat>
const Cost graph<Key, T, Cost, Nat>::operator()(const key_type& k1, const key_type& k2) const {
    return operator()(find(k1), find(k2));
}
#endif

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::insert(const graph<Key, T, Cost, Nat>::value_type &val) {
    std::pair<iterator, bool> p{_nodes.insert(val)};
    p.first->second->set_iterator_values(p.first, end(), cend());
    return p;
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::insert(const_iterator position, const value_type& val) {
    iterator it{_nodes.insert(position, val)};
    it->second->set_iterator_values(it, end(), cend());
    return it;
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::insert(const_iterator position, const key_type& k, graphed_type& x) {
    return insert(position, std::make_pair(k, std::make_shared<node>(x)));
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::insert(const_iterator position, const key_type& k, const node& n) {
    return insert(position, std::make_pair(k, std::make_shared<node>(n)));
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::emplace(const key_type& k) {
    return emplace(k, node());
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::emplace(const key_type& k, const graphed_type& x) {
    return emplace(k, node(x));
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::emplace(const key_type& k, const node& n) {
    std::pair<iterator, bool> p{_nodes.emplace(k, std::make_shared<node>(n))};
    p.first->second->set_iterator_values(p.first, end(), cend());
    return p;
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::add_node(const key_type& k) {
    return emplace(k);
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::add_node(const key_type& k, const graphed_type& x) {
    return emplace(k, x);
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::iterator, bool> graph<Key, T, Cost, Nat>::add_node(const key_type& k, const node& n) {
    return emplace(k, n);
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::add_edge(const_iterator it1, const_iterator it2, Cost cost) {
    auto new_edge = it1->second->add_edge(it2, cost);

    if (get_nature() == UNDIRECTED)
        it2->second->set_edge(it1, (new_edge.first->cost));

    if (new_edge.second)
        _num_edges++;

    return true;
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::add_edge(const key_type& k1, const key_type& k2, Cost cost) {
    return add_edge(emplace(k1).first, emplace(k2).first, cost);
}

template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::link_all_nodes(Cost cost) {
    clear_edges();

    if (cost != infinity)
        for (iterator it1 = begin(); it1 != end(); ++it1)
            for (iterator it2 = begin(); it2 != end(); ++it2)
                if (it1 != it2)
                    add_edge(it1, it2, cost);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::erase(const_iterator position) {
    clear_edges(position);

    return _nodes.erase(position);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::erase(const_iterator first, const_iterator last) {
    for (const_iterator it{first}; it != last && it != cend(); ++it)
        clear_edges(it);

    return _nodes.erase(first, last);
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::erase(const key_type& k) {
    const_iterator it{find(k)};
    if (it == cend())
        return 0;

    clear_edges(it);
    return _nodes.erase(k);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::del_node(const_iterator position) {
    return erase(position);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::del_nodes(const_iterator first, const_iterator last) {
    return erase(first, last);
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::del_node(const key_type& k) {
    return erase(k);
}
template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::clear() noexcept {
    clear_edges();
    _nodes.clear();
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::del_edge(const_iterator it1, const_iterator it2) {
    size_type result{0};
    if (it1 != end() && it2 != end()) {
        result = static_cast<size_type>(it1->second->del_edge(it2));

        if (get_nature() == UNDIRECTED)
            it2->second->del_edge(it1);

        _num_edges -= result;
    }
    return result;
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::del_edge(const key_type& k1, const key_type& k2) {
    return del_edge(find(k1), find(k2));
}

template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::clear_edges() {
    for (const_iterator it{cbegin()}; it != cend(); ++it)
        clear_edges(it);
    _num_edges = 0;
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::clear_edges(const_iterator it) {
    size_type result{0};
    if (it != cend()) {
        for (const_iterator it1{cbegin()}; it1 != cend(); ++it1)
            del_edge(it1, it);

        if (get_nature() == DIRECTED)
            result += it->second->clear_edges();

        _num_edges -= result;
    }
    return result;
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::clear_edges(const key_type& k) {
    return clear_edges(find(k));
}

template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::swap(graph& other) {
    std::swap(_nodes,     other._nodes);
    std::swap(_num_edges, other._num_edges);
}

namespace std {
    template <class Key, class T, class Cost, Nature Nat>
    inline void swap(graph<Key, T, Cost, Nat>& g1, graph<Key, T, Cost, Nat>& g2) noexcept

    {
        g1.swap(g2);
    }
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::count(const key_type& k) const {
    return _nodes.count(k);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::iterator graph<Key, T, Cost, Nat>::find(const key_type& k) {
    return _nodes.find(k);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::const_iterator graph<Key, T, Cost, Nat>::find(const key_type& k) const {
    return _nodes.find(k);
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::existing_node(const_iterator it) const {
    return it != cend();
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::existing_node(const key_type& k) const {
    return existing_node(find(k));
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::existing_edge(const_iterator it1, const_iterator it2) const {
    if (it1 != cend() && it2 != cend()) {
        if (get_nature() == DIRECTED)
            return it1->second->existing_adjacent_node(it2);
        else
            return it1->second->existing_adjacent_node(it2) && it2->second->existing_adjacent_node(it1);
    }

    return false;
}

template <class Key, class T, class Cost, Nature Nat>
bool graph<Key, T, Cost, Nat>::existing_edge(const key_type& k1, const key_type& k2) const {
    return existing_edge(find(k1), find(k2));
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::get_nbr_nodes() const noexcept {
    return _nodes.size();
}

template <class Key, class T, class Cost, Nature Nat>
std::size_t graph<Key, T, Cost, Nat>::get_nbr_edges() const noexcept {
    return _num_edges;
}

template <class Key, class T, class Cost, Nature Nat>
inline Nature graph<Key, T, Cost, Nat>::get_nature() const {
    return Nat;
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::Degree graph<Key, T, Cost, Nat>::degree(const_iterator position) const {
    if (get_nature() == DIRECTED)
        return position == cend() ? Degree::min() : Degree(position->second->degree().first, position->second->degree().second);
    return position == cend() ? Degree::min() : Degree(position->second->degree().first, 0);
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::Degree graph<Key, T, Cost, Nat>::degree(const key_type& k) const {
    return degree(find(k));
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::const_iterator, typename graph<Key, T, Cost, Nat>::Degree> graph<Key, T, Cost, Nat>::degree_max() const {
    if (empty()) return std::make_pair(cend(), Degree::min());

    Degree max{Degree::min()};
    const_iterator cit;

    for (const_iterator it{cbegin()}; it != cend(); ++it) {
        Degree tmp{degree(it)};
        if (max < tmp) {
            max = tmp;
            cit = it;
        }
    }

    return std::make_pair(cit, max);
}

template <class Key, class T, class Cost, Nature Nat>
std::pair<typename graph<Key, T, Cost, Nat>::const_iterator, typename graph<Key, T, Cost, Nat>::Degree> graph<Key, T, Cost, Nat>::degree_min() const {
    if (empty()) return std::make_pair(cend(), Degree::min());

    Degree min{Degree::max()};
    const_iterator cit;

    for (const_iterator it{cbegin()}; it != cend(); ++it) {
        Degree tmp{degree(it)};
        if (tmp < min) {
            min = tmp;
            cit = it;
        }
    }

    return std::make_pair(cit, min);
}

template <class Key, class T, class Cost, Nature Nat>
std::map<Key, typename graph<Key, T, Cost, Nat>::Degree> graph<Key, T, Cost, Nat>::degrees() const {
    std::map<key_type, Degree> result;

    for (const_iterator it{cbegin()}; it != cend(); ++it)
        result.insert(std::make_pair(it->first, degree(it)));

    return result;
}

template <class Key, class T, class Cost, Nature Nat>
std::ostream& graph<Key, T, Cost, Nat>::print(std::ostream &os) const {
    using std::setw;
    using std::ostringstream;

    const std::string tab{"    "};
    const std::string separator{","};

    //! Displaying nature + graph types
    if (get_nature() == DIRECTED)
        os << "di";
    os << "graph<" << detail::type_name<Key>()  << ", "
                   << detail::type_name<T>()    << ", "
                   << detail::type_name<Cost>() << "> {\n"
       << tab << "nodes: {\n";

    //! Displaying nodes:  "<name>"; "<value>",
    size_type max_size{3};
    for_each(cbegin(), cend(), [&max_size](const value_type &element) {
        ostringstream out;
        out << element.first;
        size_type size{static_cast<size_type>(out.tellp())};

        if (size > max_size)
            max_size = size;
    });

    for (const_iterator it{cbegin()}; it != cend(); ++it) {
        ostringstream out;
        out << it->first << '"' << separator;

        os << tab << tab
           << '"' << std::left << setw(static_cast<int>(max_size + 2 + separator.size())) << out.str()
           << '"' << it->second->get() << '"';

        if (it != --cend())
            os << ';';
        os << '\n';
    }
    os << tab << '}';

    //! Displaying edges:  "<node 1>"; "<node 2>"; "<cost>",
    if (get_nbr_edges() == 0)
        os << "\n}";
    else {
        os << ",\n" << tab << "edges: {\n";
        size_type max_size_1{0}, max_size_2{0};

        for_each(cbegin(), cend(), [&max_size_1, &max_size_2, this](const value_type &element) {
            auto child = element.second->get_edges();
            for_each(child.cbegin(), child.cend(), [&, this](const auto &i) {
                ostringstream out_1, out_2;
                out_1 << element.first;
                out_2 << i.target.lock()->container_from_this->first;

                size_type size_1{static_cast<size_type>(out_1.tellp())},
                          size_2{static_cast<size_type>(out_2.tellp())};

                if (size_1 > max_size_1)
                    max_size_1 = size_1;

                if (size_2 > max_size_2)
                    max_size_2 = size_2;
            });
        });

        size_type p{0};
        for_each(cbegin(), cend(), [=, &os, &p](const value_type &element) {
            auto child = element.second->get_edges();
            for_each(child.cbegin(), child.cend(), [=, &os, &p](const auto &i) {
                ostringstream out_1, out_2;
                out_1 << element.first << '"' << separator;
                out_2 << i.target.lock()->container_from_this->first << '"' << separator;

                os << tab << tab
                   << '"' << setw(static_cast<int>(max_size_1 + 2 + separator.size())) << out_1.str()
                   << '"' << setw(static_cast<int>(max_size_2 + 2 + separator.size())) << out_2.str();
                if (*i.cost == infinity)
                    os << "infinity";
                else
                   os << '"' << *i.cost << '"';

                if (p < (this->get_nature() == DIRECTED ?
                         this->get_nbr_edges() : 2 * this->get_nbr_edges()) - 1)
                    os << ';';
                os << '\n';
                p++;
            });
        });
        os << tab << "}\n}";
    }

    return os;
}

template <class Key, class T, class Cost, Nature Nat>
std::ostream& operator<<(std::ostream& os, const graph<Key, T, Cost, Nat>& g) {
    return g.print(os) << std::endl;
}

template <class Key, class T, class Cost, Nature Nat>
std::istream& operator>>(std::istream& is, graph<Key, T, Cost, Nat>& g) {
    g.clear();

    //! Nature
    std::string line;
    getline(is, line);
    if (line.substr(0, 5) == "graph") {
        if (g.get_nature() != UNDIRECTED)
            GRAPH_THROW_WITH(invalid_argument, "Bad graph nature (expected UNDIRECTED)")
    } else if (line.substr(0, 7) == "digraph") {
        if (g.get_nature() != DIRECTED)
            GRAPH_THROW_WITH(invalid_argument, "Bad graph nature (expected DIRECTED)")
    } else
        GRAPH_THROW_WITH(parse_error, static_cast<std::size_t>(is.tellg()), "Bad graph nature")

    //! Nodes
    getline(is, line);
    if (line != "    nodes: {")
        GRAPH_THROW_WITH(parse_error, static_cast<std::size_t>(is.tellg()), "Bad format for nodes")
    while (getline(is, line) && line.find("}") == std::string::npos) {
        std::istringstream iss{line};
        Key key;
        T value;
        detail::read_T(iss, key);
        detail::read_T(iss, value);

        g[key] = value;
    }

    //! Edges
    getline(is, line);
    if (line == "}") {}
    else if (line != "    edges: {")
        GRAPH_THROW_WITH(parse_error, static_cast<std::size_t>(is.tellg()), "Bad format for edges")
    else {
        while (getline(is, line) && line.find("}") == std::string::npos) {
            std::istringstream iss{line};
            Key from;
            Key to;
            Cost cost;
            detail::read_T(iss, from);
            detail::read_T(iss, to);
            detail::read_cost(iss, cost);

            g(from, to) = cost;
        }
    }

    getline(is, line);
    if (line != "}")
        GRAPH_THROW_WITH(parse_error, static_cast<std::size_t>(is.tellg()), "Bad format at the end of the graph")

    return is;
}

template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::save(const char *filepath) const {
    std::ofstream out(filepath);
    out << *this << std::endl;
    out.close();
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>& graph<Key, T, Cost, Nat>::load(const char *filepath) {
    std::ifstream in(filepath);
    if (in) {
        in >> *this;
        in.close();
    }

    return *this;
}

template <class Key, class T, class Cost, Nature Nat>
template <class K,   class D, class C,    Nature N>
bool graph<Key, T, Cost, Nat>::operator==(const graph<K, D, C, N> &other) const noexcept {
    typedef typename graph<Key, T, Cost, Nat>::const_iterator Iterator1;
    typedef typename graph<K,   D,    C,   N>::const_iterator Iterator2;
    typedef std::list<typename basic_node<T, Cost, typename graph<Key, T, Cost, Nat>::iterator, Iterator1>::edge> Set1;
    typedef std::list<typename basic_node<D,    C, typename graph<K,   D, C,      N>::iterator, Iterator2>::edge> Set2;

    if (get_nature()    != other.get_nature()    ||
        get_nbr_nodes() != other.get_nbr_nodes() ||
        get_nbr_edges() != other.get_nbr_edges())
        return false;

    Iterator1 it1{cbegin()};
    Iterator2 it2{other.cbegin()};

    for (; (it1 != cend() || it2 != other.cend()); ++it1, ++it2) {

        if (!(it1->first            == it2->first)         ||
            !(it1->second->get()    == it2->second->get()) ||
            !(it1->second->degree() == it2->second->degree()))
            return false;

        Set1 child1{it1->second->get_edges()};
        Set2 child2{it2->second->get_edges()};
        typename Set1::const_iterator edge1{child1.cbegin()};
        typename Set2::const_iterator edge2{child2.cbegin()};

        for (; (edge1 != child1.cend() || edge2 != child2.cend()); ++edge1, ++edge2) {
            Iterator1 target1{edge1->get_container()};
            Iterator2 target2{edge2->get_container()};

            if (!(target1->first == target2->first && *edge1->cost == *edge2->cost))
                return false;
        }
    }

    return true;
}

template <class Key, class T, class Cost, Nature Nat>
template <class K,   class D, class C,    Nature N>
bool graph<Key, T, Cost, Nat>::operator!=(const graph<K, D, C, N> &other) const noexcept {
    return !(*this == other);
}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::node::node() : node(graphed_type()) {}

template <class Key, class T, class Cost, Nature Nat>
graph<Key, T, Cost, Nat>::node::node(const graphed_type &d) {
    this->_data = d;
}

template <class Key, class T, class Cost, Nature Nat>
typename graph<Key, T, Cost, Nat>::node& graph<Key, T, Cost, Nat>::node::operator=(const graphed_type &d) {
    this->set(d);
    return *this;
}

template <class Key, class T, class Cost, Nature Nat>
void graph<Key, T, Cost, Nat>::node::set_iterator_values(iterator this_, iterator end, const_iterator cend) {
    this->container_from_this = this_;
    this->end_container       = end;
    this->cend_container      = cend;
}

#endif
